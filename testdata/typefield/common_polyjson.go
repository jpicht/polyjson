// Code generated by polyjson. DO NOT EDIT.
package typefield

import (
	"encoding/json"
	"fmt"

	"github.com/jpicht/polyjson"
	"github.com/launchdarkly/go-jsonstream/v3/jwriter"
	"github.com/mailru/easyjson/jlexer"
)

const (
	EventTypeFailedLogin = EventType("login_failed")
	EventTypeLogin       = EventType("login")
	EventTypeLogout      = EventType("logout")
)

type EventVisitor interface {
	VisitFailedLogin(FailedLogin)
	VisitLogin(Login)
	VisitLogout(Logout)
}

type Event struct {
	// common data
	Common

	// implementations
	FailedLogin *FailedLogin `json:"failed_login,omitempty"`
	Login       *Login       `json:"login,omitempty"`
	Logout      *Logout      `json:"logout,omitempty"`
}

type (
	EventSlice   []Event
	EventBuilder struct {
		Common
	}
)

func NewEvent(c Common) EventBuilder {
	return EventBuilder{Common: c}
}

func (b EventBuilder) FailedLogin(value FailedLogin) Event {
	return Event{
		Common:      b.Common,
		FailedLogin: &value,
	}
}

func (b EventBuilder) Login(value Login) Event {
	return Event{
		Common: b.Common,
		Login:  &value,
	}
}

func (b EventBuilder) Logout(value Logout) Event {
	return Event{
		Common: b.Common,
		Logout: &value,
	}
}

func (s *EventSlice) Append(value Event) {
	*s = append(*s, value)
}

func (s *EventSlice) AppendFailedLogin(c Common, value FailedLogin) {
	*s = append(*s, Event{
		Common:      c,
		FailedLogin: &value,
	})
}

func (s *EventSlice) AppendLogin(c Common, value Login) {
	*s = append(*s, Event{
		Common: c,
		Login:  &value,
	})
}

func (s *EventSlice) AppendLogout(c Common, value Logout) {
	*s = append(*s, Event{
		Common: c,
		Logout: &value,
	})
}

func (ps *Event) Accept(v EventVisitor) bool {
	if ps.FailedLogin != nil {
		v.VisitFailedLogin(*ps.FailedLogin)
		return true
	}
	if ps.Login != nil {
		v.VisitLogin(*ps.Login)
		return true
	}
	if ps.Logout != nil {
		v.VisitLogout(*ps.Logout)
		return true
	}
	return false
}

func (pss EventSlice) Accept(v EventVisitor) bool {
	for _, e := range pss {
		if !e.Accept(v) {
			return false
		}
	}
	return true
}

func (ps *Event) WriteToJSONWriter(w *jwriter.Writer) {
	o := w.Object()
	defer o.End()

	// common fields from Common
	var (
		raw []byte
		err error
	)
	raw, err = json.Marshal(ps.Common.Time)
	o.Maybe("time", len(raw) > 0).Raw(raw)
	w.AddError(err)
	raw, err = json.Marshal(ps.Common.Type)
	o.Maybe("type", len(raw) > 0).Raw(raw)
	w.AddError(err)
	raw, err = json.Marshal(ps.Common.UserID)
	o.Maybe("user_id", len(raw) > 0).Raw(raw)
	w.AddError(err)
	raw, err = json.Marshal(ps.Common.ActualUserID)
	o.Maybe("actual_user_id", len(raw) > 0).Raw(raw)
	w.AddError(err)

	// implementations
	if ps.FailedLogin != nil {
		raw, err := json.Marshal(ps.FailedLogin)
		o.Maybe("failed_login", len(raw) > 0).Raw(raw)
		w.AddError(err)
	} else if ps.Login != nil {
		raw, err := json.Marshal(ps.Login)
		o.Maybe("login", len(raw) > 0).Raw(raw)
		w.AddError(err)
	} else if ps.Logout != nil {
		raw, err := json.Marshal(ps.Logout)
		o.Maybe("logout", len(raw) > 0).Raw(raw)
		w.AddError(err)
	} else {
		w.AddError(polyjson.ErrNoValue)
	}
	// FIXME: additionals are not implemented yet
}

func (ps *Event) MarshalJSON() ([]byte, error) {
	w := jwriter.NewWriter()
	ps.WriteToJSONWriter(&w)
	return w.Bytes(), w.Error()
}

func (ps *Event) UnmarshalEasyJSON(in *jlexer.Lexer) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}

	cache := make(map[string]json.RawMessage)

	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(true)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		// common fields from Common
		case "time":
			in.AddError(ps.Common.Time.UnmarshalJSON(in.Raw()))

		case "type":
			in.AddError(json.Unmarshal(in.Raw(), &ps.Common.Type))

		case "user_id":
			in.AddError(json.Unmarshal(in.Raw(), &ps.Common.UserID))

		case "actual_user_id":
			in.AddError(json.Unmarshal(in.Raw(), &ps.Common.ActualUserID))

		// cache all fields
		default:
			cache[key] = in.Raw()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}

	raw, err := json.Marshal(cache)
	in.AddError(err)
	cache = nil

	switch ps.Common.Type {
	case EventTypeFailedLogin:
		ps.FailedLogin = &FailedLogin{
			Implements: polyjson.Implements[Event]{Parent: ps},
		}
		in.AddError(json.Unmarshal(raw, ps.FailedLogin))

	case EventTypeLogin:
		ps.Login = &Login{
			Implements: polyjson.Implements[Event]{Parent: ps},
		}
		in.AddError(json.Unmarshal(raw, ps.Login))

	case EventTypeLogout:
		ps.Logout = &Logout{
			Implements: polyjson.Implements[Event]{Parent: ps},
		}
		in.AddError(json.Unmarshal(raw, ps.Logout))

	case "":
		in.AddError(polyjson.ErrMissingTypeID)
		return
	default:
		in.AddError(fmt.Errorf("%w: %s", polyjson.ErrInvalidTypeID, ps.Common.Type))
		return
	}
}

func (ps *Event) UnmarshalJSON(data []byte) error {
	l := &jlexer.Lexer{Data: data}
	ps.UnmarshalEasyJSON(l)
	return l.Error()
}

type EventDefaultVisitor struct{}

func (EventDefaultVisitor) VisitFailedLogin(FailedLogin) {}
func (EventDefaultVisitor) VisitLogin(Login)             {}
func (EventDefaultVisitor) VisitLogout(Logout)           {}

type (
	FailedLoginVisitorFunc func(FailedLogin)
	LoginVisitorFunc       func(Login)
	LogoutVisitorFunc      func(Logout)
)

type EventFuncVisitor struct {
	FailedLoginVisitorFunc FailedLoginVisitorFunc
	LoginVisitorFunc       LoginVisitorFunc
	LogoutVisitorFunc      LogoutVisitorFunc
}

func (fv EventFuncVisitor) VisitFailedLogin(value FailedLogin) {
	if fv.FailedLoginVisitorFunc != nil {
		fv.FailedLoginVisitorFunc(value)
	}
}

func (fv EventFuncVisitor) VisitLogin(value Login) {
	if fv.LoginVisitorFunc != nil {
		fv.LoginVisitorFunc(value)
	}
}

func (fv EventFuncVisitor) VisitLogout(value Logout) {
	if fv.LogoutVisitorFunc != nil {
		fv.LogoutVisitorFunc(value)
	}
}
